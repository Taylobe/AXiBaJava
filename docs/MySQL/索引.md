# 索引

## 什么是索引

索引是关系数据库中一种特殊的存储结构，并不属于关系模型的组成部分。

可以理解成是一个**排序的列表**，存储着索引的值和包含这个值的数据所在行的物理地址。

有点类似图书的目录，可以根据目录中的页码快速找到所需的内容。

- 优点：
  - 加快检索速度，减少I/O次数，提升查找效率。
  - 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。
- 缺点：
  - 索引本身也是表，会占有一定的存储空间。索引表的维护和创建需要时间成本，这个成本与数据量成正比。
  - 构建索引会降低数据表操作(增加、删除、修改)的效率。操作数据表的同时也需要操作索引表。

> 索引的本质：实际上是以空间换时间。



## 索引结构

### Full-Text 索引

即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。

- 优点：

  通过建立**倒排索引**，极大的提升检索效率，解决判断字段是否包含的问题。

- 缺点：

  - 支持引擎太局限。
  - 支持数据类型太局限。

> 倒排索引(Inverted index)，也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。



### Hash索引

常见的索引结构，存储结构是key-value形式存在数组中，然后通过hash函数(key)得到一个值，这个值就是它们的索引。当取数据的时候，key通过hash得到索引值，直接找就行了，复杂度为o(1)。

- 优点：

  单条记录查询的效率很高，时间复杂度为1。适合**精确查找**。

- 缺点：

  - 有可能出现hash冲突的情况。
  - 对于不等值的查找，不能避免全表扫描。
  - hash码是毫无规律可言的，并不能顺序性。不适合**范围查找**。



### 二叉树

左子节点值 < 节点值 < 右子节点值 。当数据量非常大时，要查找的数据又非常靠后，和没有索引相比，那么二叉树结构的查询优势将非常明显。

- 优点：

  查找减半。

- 缺点：

  如果数据是单边增长的情况，那么会出现**单链**情况。树高度大，完全无意义。



### 红黑树(二叉平衡树)

一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

- 优点：

  当节点为3时，会自动分解平衡(解决二叉树的极端问题)。

- 缺点：

  - 自动平衡，特别消耗性能。
  - 节点的高度是无法预测的，磁盘I/O操作也不可控。



### B-Tree

B-Tree 是一种平衡的多路查找树，很好的解决红黑树遗留的树高问题。叶子节点具有相同的深度，叶节点的指针为空，所有索引元素不重复。

- 优点：
  - 一次可以设置多个节点，降低了树的高度，所以查找很快。
  - 节点中的数据key从左到右依次递增。
- 缺点：
  - 根节点不仅存了索引key也存了对应的记录，所以比较占用空间。
  - 当数据量较大的时候，同样会导致B树很深，从而增加了磁盘 IO 的次数，进而影响查询效率。



### B+Tree

B-Tree的变种。所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

- 优点：

  - 非叶子节点不存储data，只存储索引，可以存放更多索引。
  - 树的层级更少，查询数据速度更快。
  - 所有叶子节点数据构成了一个有序链表，查询大小区间的数据时更方便。
  - 全节点遍历更快，利于数据库做全表扫描。

- 缺点：

  B+树最大的性能问题在于会产生大量的随机IO，主要存在以下两种情况：

  - 主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片。

  - 即使主键是有序递增的，大量写请求的分布仍是随机的。



### 综述：为什么 MySQL 会选择 B+Tree 当索引数据结构？

- B+Tree 相对于 Full-Text 索引结构的优势：

  Full-Text 索引存在一定的局限性，而B+Tree有更多的可能性。

- B+Tree 相对于 Hash 表存储结构的优势：

  范围查询是 MySQL 中常见的场景，但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

- B+Tree 相对于二叉树索引结构的优势：

  二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。而对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)。也就是说，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据

- B+Tree 相对于 B 树 索引结构的优势：

  B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。




## 存储引擎

### MyISAM

MySQL(**5.5版之前**)的默认数据库引擎，**非聚集索引**，使用**B+Tree**作为索引结构。索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

### InnoDB

MySQL(**5.5版之后**)的默认数据库引擎，**聚集索引**，使用**B+Tree**作为索引结构。数据文件是和(主键)索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。

### Memory

MySQL中特殊的存储引擎，也称**HEAP存储引擎**。默认使用**HASH**作为索引结构，也支持BTree。其使用存储在内存中的内容来创建表，而且所有数据也放在内存中。服务器重启后，只有表结构(保存在磁盘文件中)，没有表数据(存储在内存中)。



### 总结

|    索引类型    | MyISAM 引擎 | InnoDB 引擎 | Memory 引擎 |
| :------------: | :---------: | :---------: | :---------: |
| Full-Text 索引 |      ☑️      |      ✖️      |      ✖️      |
|   Hash 索引    |      ✖️      |      ✖️      |      ☑️      |
|  B+Tree 索引   |      ☑️      |      ☑️      |      ☑️      |



### 比较

|     区别点     |                  MyISAM 引擎                  |                     InnoDB 引擎                      |
| :------------: | :-------------------------------------------: | :--------------------------------------------------: |
|      事务      |                       ✖️                       |                          ☑️                           |
|      外键      |                       ✖️                       |                          ☑️                           |
|    具体行数    |                       ☑️                       |                          ✖️                           |
|    全文索引    |                       ☑️                       |                   ☑️(MySQL5.7以后)                    |
|     锁粒度     |                     表锁                      |                   表锁、行锁(默认)                   |
|    要有主键    |                   ✖️(不一定)                   |   ☑️(没有指定，MySQL自己生成隐藏列Row_id来充当主键)   |
| 索引和数据文件 |                     分离                      | 不分离(表数据文件本身就是按B+Tree组织的一个索引结构) |
|    存储文件    | frm是表定义文件，myd是数据文件，myi是索引文件 |            frm是表定义文件，ibd是数据文件            |



## 索引类型

### 功能划分

- 普通索引

  最基本的索引，它没有任何限制,就是为了加快搜索速度。

- 唯一索引

  索引列的值必须唯一，但允许有空值。若是组合索引，列值的组合必须唯一。

- 主键索引

  特殊的唯一索引，不允许有空值，表中只有一个。

  > 主键索引灵魂三问：
  >
  > - 为什么非主键索引结构叶子节点存储的是主键值？
  >
  >   - 保证一致性，更新数据的时候只需要更新主键索引树。
  >   - 节省存储空间，指向主键的节点，不用再存储一份相同的数据。
  >
  > - 为什么推荐InnoDB表必须有主键？
  >
  >   保证会有主键索引树的存在(因为数据存放在主键索引树上面)，如果没有MySQL会自己生成一个rowid作为自增的主键主键索引。
  >
  > - 为什么推荐使用整型的自增主键？
  >
  >   - **后面的主键索引总是大于前面的主键索引**，在做范围查询时，非常方便找到需要的数据。
  >   - 在添加的过程中，因为是自增的，每次添加都是在**后面插入**，树分裂的机会小。
  >   - UUID大小不确定，分裂机会大，需要**重新平衡树结构**，性能损耗大。

- 组合索引

  多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循**最左匹配原则**。

  > **最左匹配原则**：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

- 全文索引

  查找文本中的关键字，而不是直接与索引中的值相比较。更像是一个搜索引擎，而不是简单的where语句的参数匹配。目前只有char、varchar，text 列上可以创建全文索引。

  > 注意事项：在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。



### 空间划分

- 聚集索引

  数据行的物理顺序与列值（**一般是主键的那一列**）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

- 非聚集索引

  索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。



## 索引执行

使用**explain**关键字 + SQL语句观察索引的执行计划。

![MySQL执行计划](https://static01.imgkr.com/temp/077fbc08e0d0425e88e7fff80edf9102.png)

执行计划包含的参数及描述说明：

|     字段      |                             描述                             |
| :-----------: | :----------------------------------------------------------: |
|      id       |                         执行计划 id                          |
|  select_type  |                          查询的类型                          |
|     table     |                         查询的哪张表                         |
|  partitions   |                        匹配的分区信息                        |
|     type      |                           访问类型                           |
| possible_keys |                       可能会用到的索引                       |
|      key      |                        实际使用的索引                        |
|    key_len    |                      索引中使用的字节数                      |
|      ref      |                   显示索引的哪一列被使用了                   |
|     rows      | 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数 |
|    filter     |           某个表经过搜索条件过滤后剩余条数的百分比           |
|     Extra     |         包含不适合在其他列中显示但十分重要的额外信息         |



需要我们重点关注**tpye**字段，它表示数据的扫描类型，也就是描述了找到所需数据时使用的扫描方式是什么，考虑到查询效率问题，全表扫描和全索引扫描要尽量避免。常见的扫描类型如下表(根据执行效率从低到高排序)：

|  type  |               描述               |
| :----: | :------------------------------: |
|  ALL   |             全表扫描             |
| index  |            全索引扫描            |
| range  |           索引范围扫描           |
|  ref   |          非唯一索引扫描          |
| eq_ref |           唯一索引扫描           |
| const  | 结果只有一条的主键或唯一索引扫描 |



## 索引优化

### 前缀索引优化

前缀索引就是用某个字段中，字符串的前几个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

> 前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。



### 覆盖索引优化

覆盖索引是指 SQL 中 query 的所有字段，在索引 B+tree 的叶子节点上都能找得到的那些索引，从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得。例如建立一个组合索引，查询将不会再次检索主键索引，从而避免**回表**。即不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。

> **回表**：根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的。



### 联合索引优化

联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。所以建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把**区分度**大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。

> **区分度**：某个字段 column 不同值的个数除以表的总行数，比如性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 uuid 这类字段就比较适合做索引或排在联合索引列的靠前的位置。

![区分度计算公式](https://static01.imgkr.com/temp/e6ab25358b784660a60fdeb0793aa775.png)



### 使用原则

### 什么时候适用索引

- 字段有唯一性限制的字段。
- 经常用于 WHERE 查询条件的字段。
- 经常用于 GROUP BY 和 ORDER BY 的字段。



### 什么时候不需要创建索引

- WHERE 查询条件，GROUP BY，ORDER BY 里用不到的字段。
- 字段中存在大量重复的数据。
- 表数据太少
- 经常更新的字段不需要创建索引，避免索引的维护成本高。



### 什么情况下索引失效

- 如果索引进行了表达式计算。
- 如果索引适用了函数。
- 当使用 **LIKE** 关键字进行模糊查询的时候，后面不能是 **%** 。
- 使用联合索引的时候，**最左原则**没有匹配。
- 索引列存在 **NULL** 的情况 

